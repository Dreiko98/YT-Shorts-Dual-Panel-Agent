#!/usr/bin/env python3
"""
ü§ñ YT Shorts CLI Control Interface
Interfaz de l√≠nea de comandos para controlar el pipeline sin Telegram
"""

import os
import sys
import json
import time
import threading
from datetime import datetime
from pathlib import Path

# A√±adir src al path para imports
sys.path.append('src')

try:
    from pipeline.db import PipelineDB
    from pipeline.content_scorer import ContentScorer
    from pipeline.template_manager import TemplateManager
    from datetime import timedelta
    # Import condicional del parser
    try:
        from utils.youtube_parser import YouTubeURLParser, parse_youtube_url
        YOUTUBE_PARSER_AVAILABLE = False  # Forzar modo manual para demo
    except ImportError:
        YOUTUBE_PARSER_AVAILABLE = False
except ImportError as e:
    print(f"‚ùå Error importando m√≥dulos: {e}")
    print("Aseg√∫rate de ejecutar desde el directorio ra√≠z del proyecto")
    sys.exit(1)

def format_duration(seconds):
    """Formatear duraci√≥n en formato legible"""
    if seconds < 60:
        return f"{seconds}s"
    minutes = seconds // 60
    secs = seconds % 60
    if secs:
        return f"{minutes}m {secs}s"
    return f"{minutes}m"

class CLIControl:
    def __init__(self):
        self.db = PipelineDB()
        self.scorer = ContentScorer()
        self.template_manager = TemplateManager()
        
        # Inicializar parser de YouTube si est√° disponible
        if YOUTUBE_PARSER_AVAILABLE:
            self.youtube_parser = YouTubeURLParser()
        else:
            self.youtube_parser = None
            
        self.running = True
    
    def show_banner(self):
        """Mostrar banner de bienvenida"""
        print("="*80)
        print("üíª YT SHORTS PIPELINE - CONTROL CLI")
        print("üîß Interfaz temporal mientras recuperas acceso a Telegram")
        print("="*80)
    
    def show_menu(self):
        """Mostrar men√∫ principal"""
        print("\nüìã MEN√ö PRINCIPAL:")
        print("1Ô∏è‚É£  üìä Ver estado y estad√≠sticas")
        print("2Ô∏è‚É£  üîÑ Ver cola de shorts pendientes") 
        print("3Ô∏è‚É£  ‚úÖ Aprobar short espec√≠fico")
        print("4Ô∏è‚É£  ‚ùå Rechazar short espec√≠fico")
        print("5Ô∏è‚É£  üìÖ Programar publicaci√≥n")
        print("6Ô∏è‚É£  üì¶ Operaciones en lote")
        print("7Ô∏è‚É£  ‚è∏Ô∏è  Pausar/Reanudar daemon")
        print("8Ô∏è‚É£  üì§ Publicar shorts aprobados")
        print("9Ô∏è‚É£  üìù Ver informaci√≥n del sistema")
        print("üéØ  ü§ñ Ejecutar scoring autom√°tico")
        print("üé®  üé¨ Gestionar templates")
        print("üì∫  üìã Gestionar canales y videos")
        print("0Ô∏è‚É£  üö™ Salir")
        print("-"*50)
    
    def show_stats(self):
        """Mostrar estad√≠sticas del sistema"""
        print("\nüìä ESTAD√çSTICAS DEL SISTEMA")
        print("-"*40)
        
        # Estad√≠sticas de colas
        queue_stats = self.db.get_queue_stats()
        print(f"üîÑ Pendientes de revisi√≥n: {queue_stats['pending_review']}")
        print(f"‚úÖ Aprobados para publicar: {queue_stats['approved']}")
        print(f"‚ùå Rechazados: {queue_stats['rejected']}")
        print(f"üì§ Publicados: {queue_stats['published']}")
        
        # Estado del daemon
        daemon_paused = self.db.is_daemon_paused()
        status = "‚è∏Ô∏è  PAUSADO" if daemon_paused else "‚ñ∂Ô∏è  EJECUT√ÅNDOSE"
        print(f"ü§ñ Estado del daemon: {status}")
        
        # Estad√≠sticas generales
        try:
            general_stats = self.db.get_stats()
            print(f"üì∫ Total videos procesados: {general_stats.get('total_videos', 0)}")
            print(f"üé¨ Total shorts generados: {general_stats.get('composites', 0)}")
        except:
            print("üìä Estad√≠sticas generales no disponibles")
        
        # M√©tricas calculadas
        total_reviewed = queue_stats['approved'] + queue_stats['rejected']
        if total_reviewed > 0:
            approval_rate = queue_stats['approved'] / total_reviewed * 100
            print(f"üìà Tasa de aprobaci√≥n: {approval_rate:.1f}%")
    
    def show_pending_queue(self):
        """Mostrar cola de shorts pendientes"""
        print("\nüîÑ COLA DE SHORTS PENDIENTES")
        print("-"*40)
        
        pending = self.db.get_pending_review_composites(limit=20)
        
        if not pending:
            print("üì≠ No hay shorts pendientes de revisi√≥n")
            return
        
        for i, short in enumerate(pending, 1):
            print(f"\n{i}. üì± ID: {short['clip_id'][:16]}...")
            
            # Obtener detalles completos
            details = self.db.get_composite_details(short['clip_id'])
            if details:
                title = details.get('original_title', 'Sin t√≠tulo')
                print(f"   üìù T√≠tulo: {title[:60]}{'...' if len(title) > 60 else ''}")
                print(f"   ‚è±Ô∏è  Duraci√≥n: {details.get('duration_seconds', 0):.1f}s")
                print(f"   üìÖ Creado: {details.get('created_at', 'N/A')[:16]}")
                
                # Mostrar path del archivo si existe
                if details.get('output_path'):
                    file_path = Path(details['output_path'])
                    if file_path.exists():
                        size_mb = file_path.stat().st_size / (1024*1024)
                        print(f"   üìÅ Archivo: {file_path.name} ({size_mb:.1f}MB)")
                    else:
                        print(f"   ‚ö†Ô∏è  Archivo no encontrado: {file_path.name}")
            else:
                print(f"   üìÖ Creado: {short.get('created_at', 'N/A')[:16]}")
    
    def approve_short(self):
        """Aprobar un short espec√≠fico"""
        self.show_pending_queue()
        if not self.db.get_pending_review_composites(limit=1):
            return
        
        clip_id = input("\n‚úÖ Ingresa el ID del short a aprobar (o Enter para cancelar): ").strip()
        if not clip_id:
            return
        
        comment = input("üí¨ Comentario (opcional): ").strip()
        
        if self.db.approve_composite(clip_id, comment=comment or "Aprobado v√≠a CLI"):
            print(f"‚úÖ Short {clip_id[:16]} aprobado exitosamente")
        else:
            print(f"‚ùå Error aprobando short {clip_id}")
    
    def reject_short(self):
        """Rechazar un short espec√≠fico"""
        self.show_pending_queue()
        if not self.db.get_pending_review_composites(limit=1):
            return
        
        clip_id = input("\n‚ùå Ingresa el ID del short a rechazar (o Enter para cancelar): ").strip()
        if not clip_id:
            return
        
        reason = input("üí¨ Motivo del rechazo: ").strip()
        if not reason:
            reason = "Rechazado v√≠a CLI"
        
        if self.db.reject_composite(clip_id, reason=reason):
            print(f"‚ùå Short {clip_id[:16]} rechazado exitosamente")
        else:
            print(f"‚ùå Error rechazando short {clip_id}")
    
    def schedule_short(self):
        """Programar publicaci√≥n de un short"""
        self.show_pending_queue()
        if not self.db.get_pending_review_composites(limit=1):
            return
        
        clip_id = input("\nüìÖ Ingresa el ID del short a programar (o Enter para cancelar): ").strip()
        if not clip_id:
            return
        
        print("\nüìÖ Formatos de fecha aceptados:")
        print("   ‚Ä¢ 2024-08-19T18:00 (fecha espec√≠fica)")
        print("   ‚Ä¢ +2h (en 2 horas)")  
        print("   ‚Ä¢ +30m (en 30 minutos)")
        
        time_input = input("‚è∞ Hora de publicaci√≥n: ").strip()
        if not time_input:
            return
        
        # Parsear tiempo
        scheduled_at = self.parse_time(time_input)
        if not scheduled_at:
            print("‚ùå Formato de fecha inv√°lido")
            return
        
        if self.db.approve_composite(clip_id, scheduled_at=scheduled_at, comment="Programado v√≠a CLI"):
            print(f"üìÖ Short {clip_id[:16]} programado para {scheduled_at}")
        else:
            print(f"‚ùå Error programando short {clip_id}")
    
    def parse_time(self, time_input):
        """Parsear entrada de tiempo"""
        try:
            # Formato ISO directo
            if 'T' in time_input:
                datetime.fromisoformat(time_input)
                return time_input
            
            # Formato relativo
            if time_input.startswith('+'):
                import re
                match = re.match(r'\+(\d+)([hm])', time_input.lower())
                if match:
                    amount = int(match.group(1))
                    unit = match.group(2)
                    
                    if unit == 'h':
                        target = datetime.now() + timedelta(hours=amount)
                    else:  # 'm'
                        target = datetime.now() + timedelta(minutes=amount)
                    
                    return target.isoformat()
            
            return None
        except:
            return None
    
    def bulk_operations(self):
        """Men√∫ de operaciones en lote"""
        print("\nüì¶ OPERACIONES EN LOTE")
        print("-"*30)
        print("1. ‚úÖ Aprobar todos los pendientes")
        print("2. ‚ùå Rechazar todos los pendientes") 
        print("3. ‚úÖ Aprobar primeros N")
        print("4. ‚ùå Rechazar primeros N")
        print("5. üìä Estad√≠sticas detalladas")
        print("0. üîô Volver")
        
        choice = input("\nüëâ Selecciona opci√≥n: ").strip()
        
        if choice == '1':
            self.bulk_approve_all()
        elif choice == '2':
            self.bulk_reject_all()
        elif choice == '3':
            self.bulk_approve_n()
        elif choice == '4':
            self.bulk_reject_n()
        elif choice == '5':
            self.detailed_stats()
    
    def bulk_approve_all(self):
        """Aprobar todos los pendientes"""
        pending = self.db.get_pending_review_composites(limit=50)
        if not pending:
            print("üì≠ No hay shorts pendientes")
            return
        
        confirm = input(f"‚ö†Ô∏è  ¬øAprobar TODOS los {len(pending)} shorts pendientes? (s/N): ")
        if confirm.lower() != 's':
            return
        
        count = 0
        for short in pending:
            if self.db.approve_composite(short['clip_id'], comment="Aprobaci√≥n masiva v√≠a CLI"):
                count += 1
        
        print(f"‚úÖ {count}/{len(pending)} shorts aprobados en lote")
    
    def bulk_reject_all(self):
        """Rechazar todos los pendientes"""
        pending = self.db.get_pending_review_composites(limit=50)
        if not pending:
            print("üì≠ No hay shorts pendientes")
            return
        
        reason = input("üí¨ Motivo del rechazo masivo: ").strip()
        if not reason:
            reason = "Rechazo masivo v√≠a CLI"
        
        confirm = input(f"‚ö†Ô∏è  ¬øRechazar TODOS los {len(pending)} shorts pendientes? (s/N): ")
        if confirm.lower() != 's':
            return
        
        count = 0
        for short in pending:
            if self.db.reject_composite(short['clip_id'], reason=reason):
                count += 1
        
        print(f"‚ùå {count}/{len(pending)} shorts rechazados en lote")
    
    def bulk_approve_n(self):
        """Aprobar primeros N shorts"""
        n = input("üìù ¬øCu√°ntos shorts aprobar?: ")
        try:
            n = int(n)
        except ValueError:
            print("‚ùå N√∫mero inv√°lido")
            return
        
        pending = self.db.get_pending_review_composites(limit=n)
        if not pending:
            print("üì≠ No hay shorts pendientes")
            return
        
        count = 0
        for short in pending:
            if self.db.approve_composite(short['clip_id'], comment=f"Aprobaci√≥n lote {n} v√≠a CLI"):
                count += 1
        
        print(f"‚úÖ {count}/{len(pending)} shorts aprobados")
    
    def bulk_reject_n(self):
        """Rechazar primeros N shorts"""
        n = input("üìù ¬øCu√°ntos shorts rechazar?: ")
        try:
            n = int(n)
        except ValueError:
            print("‚ùå N√∫mero inv√°lido")
            return
        
        reason = input("üí¨ Motivo del rechazo: ").strip()
        if not reason:
            reason = f"Rechazo lote {n} v√≠a CLI"
        
        pending = self.db.get_pending_review_composites(limit=n)
        if not pending:
            print("üì≠ No hay shorts pendientes")
            return
        
        count = 0
        for short in pending:
            if self.db.reject_composite(short['clip_id'], reason=reason):
                count += 1
        
        print(f"‚ùå {count}/{len(pending)} shorts rechazados")
    
    def detailed_stats(self):
        """Mostrar estad√≠sticas detalladas"""
        print("\nüìä ESTAD√çSTICAS DETALLADAS")
        print("-"*50)
        
        queue_stats = self.db.get_queue_stats()
        
        print("üîÑ Estado de las colas:")
        print(f"   ‚Ä¢ Pendientes: {queue_stats['pending_review']}")
        print(f"   ‚Ä¢ Aprobados: {queue_stats['approved']}")
        print(f"   ‚Ä¢ Rechazados: {queue_stats['rejected']}")
        print(f"   ‚Ä¢ Publicados: {queue_stats['published']}")
        
        # M√©tricas calculadas
        total_shorts = sum(queue_stats.values())
        total_reviewed = queue_stats['approved'] + queue_stats['rejected']
        
        print(f"\nüìà M√©tricas:")
        print(f"   ‚Ä¢ Total shorts: {total_shorts}")
        print(f"   ‚Ä¢ Total revisados: {total_reviewed}")
        
        if total_reviewed > 0:
            approval_rate = queue_stats['approved'] / total_reviewed * 100
            print(f"   ‚Ä¢ Tasa aprobaci√≥n: {approval_rate:.1f}%")
        
        if total_shorts > 0:
            publish_rate = queue_stats['published'] / total_shorts * 100
            print(f"   ‚Ä¢ Tasa publicaci√≥n: {publish_rate:.1f}%")
    
    def toggle_daemon(self):
        """Pausar/reanudar daemon"""
        current_state = self.db.is_daemon_paused()
        action = "reanudar" if current_state else "pausar"
        
        confirm = input(f"‚ö†Ô∏è  ¬ø{action.capitalize()} el daemon? (s/N): ")
        if confirm.lower() != 's':
            return
        
        new_state = not current_state
        if self.db.set_daemon_paused(new_state):
            status = "pausado" if new_state else "reanudado"
            print(f"üîÑ Daemon {status} exitosamente")
        else:
            print("‚ùå Error cambiando estado del daemon")
    
    def publish_approved(self):
        """Publicar shorts aprobados"""
        approved = self.db.get_approved_composites(limit=10)
        if not approved:
            print("üì≠ No hay shorts aprobados para publicar")
            return
        
        print(f"üì§ Hay {len(approved)} shorts aprobados para publicar")
        print("‚ö†Ô∏è  Funci√≥n de publicaci√≥n requiere configuraci√≥n completa de YouTube API")
        print("üí° Usa el daemon autom√°tico o configura el publisher para publicar")
    
    def show_system_info(self):
        """Mostrar informaci√≥n del sistema"""
        print("\nüìù INFORMACI√ìN DEL SISTEMA")
        print("-"*40)
        
        # Info de la base de datos
        if Path('data/pipeline.db').exists():
            size_mb = Path('data/pipeline.db').stat().st_size / (1024*1024)
            print(f"üíæ Base de datos: {size_mb:.2f}MB")
        
        # Archivos de log
        if Path('logs').exists():
            log_files = list(Path('logs').glob('*.log'))
            print(f"üìù Archivos de log: {len(log_files)}")
        
        # Estado de configuraci√≥n
        config_files = ['configs/channels.yaml', '.env']
        for config in config_files:
            if Path(config).exists():
                print(f"‚úÖ {config}")
            else:
                print(f"‚ùå {config} (no encontrado)")
        
        # Alternativas para usar el bot
        print(f"\nüí° ALTERNATIVAS MIENTRAS RECUPERAS TELEGRAM:")
        print(f"   ‚Ä¢ Esta interfaz CLI")
        print(f"   ‚Ä¢ Interfaz web: python web_interface.py (requiere Flask)")
        print(f"   ‚Ä¢ Scripts Python personalizados")
        print(f"   ‚Ä¢ Edici√≥n directa de la base de datos")
    
    def run_auto_scoring(self):
        """Ejecutar sistema de scoring autom√°tico"""
        print("\nü§ñ SISTEMA DE SCORING AUTOM√ÅTICO")
        print("-" * 40)
        
        print("1. üéØ Procesar shorts pendientes")
        print("2. üìä Ver estad√≠sticas de scoring")
        print("3. ‚öôÔ∏è Configurar thresholds")
        print("4. üîç Analizar short espec√≠fico")
        print("0. üîô Volver")
        
        choice = input("\nüëâ Selecciona opci√≥n: ").strip()
        
        if choice == '1':
            self.process_pending_scoring()
        elif choice == '2':
            self.show_scoring_stats()
        elif choice == '3':
            self.configure_scoring_thresholds()
        elif choice == '4':
            self.analyze_specific_short()
    
    def process_pending_scoring(self):
        """Procesar shorts pendientes con scoring"""
        print("\nüîÑ Procesando shorts pendientes...")
        
        try:
            results = self.scorer.process_pending_shorts()
            
            if not results['processed']:
                print("üì≠ No hay shorts pendientes para procesar")
                return
            
            print(f"‚úÖ Procesados: {results['processed']} shorts")
            print(f"üéØ Auto-aprobados: {results['auto_approved']}")
            print(f"‚ùå Auto-rechazados: {results['auto_rejected']}")
            print(f"‚è≥ Requieren revisi√≥n manual: {results['needs_manual_review']}")
            
            if results['errors']:
                print(f"‚ö†Ô∏è  Errores: {results['errors']}")
            
        except Exception as e:
            print(f"‚ùå Error procesando scoring: {e}")
    
    def show_scoring_stats(self):
        """Mostrar estad√≠sticas del sistema de scoring"""
        print("\nüìä ESTAD√çSTICAS DE SCORING")
        print("-" * 40)
        
        try:
            stats = self.scorer.get_scoring_stats()
            
            basic = stats.get('basic_stats', {})
            distribution = stats.get('score_distribution', {})
            thresholds = stats.get('threshold_stats', {})
            
            print("üìà Estad√≠sticas B√°sicas:")
            print(f"   ‚Ä¢ Total evaluados: {basic.get('total_scored', 0)}")
            print(f"   ‚Ä¢ Score promedio: {basic.get('avg_score', 0):.1f}")
            print(f"   ‚Ä¢ Auto-rechazos elegibles: {basic.get('auto_rejected_eligible', 0)}")
            
            print("\nüìä Distribuci√≥n de Scores:")
            for category, count in distribution.items():
                print(f"   ‚Ä¢ {category.title()}: {count}")
            
            if thresholds:
                print("\n‚öôÔ∏è  Estad√≠sticas de Thresholds:")
                for threshold, count in thresholds.items():
                    print(f"   ‚Ä¢ {threshold}: {count}")
                    
        except Exception as e:
            print(f"‚ùå Error obteniendo estad√≠sticas: {e}")
    
    def configure_scoring_thresholds(self):
        """Configurar thresholds del sistema de scoring"""
        print("\n‚öôÔ∏è CONFIGURAR THRESHOLDS DE SCORING")
        print("-" * 40)
        
        print("Thresholds actuales:")
        print(f"   ‚Ä¢ Auto-aprobar: ‚â• 80 puntos")
        print(f"   ‚Ä¢ Auto-rechazar: < 40 puntos")
        print(f"   ‚Ä¢ Revisi√≥n manual: 40-79 puntos")
        
        print("\n‚ö†Ô∏è  Modificaci√≥n de thresholds requiere editar el c√≥digo fuente")
        print("üìÅ Archivo: src/pipeline/content_scorer.py")
        print("üìç L√≠neas: auto_approve_threshold y auto_reject_threshold")
    
    def analyze_specific_short(self):
        """Analizar un short espec√≠fico"""
        print("\nüîç ANALIZAR SHORT ESPEC√çFICO")
        print("-" * 40)
        
        clip_id = input("üìÑ Ingresa el clip_id del short: ").strip()
        
        if not clip_id:
            print("‚ùå Clip ID requerido")
            return
        
        try:
            # Buscar el short en la base de datos
            shorts = self.db.get_pending_review_composites()
            short = None
            
            for s in shorts:
                if s['clip_id'] == clip_id:
                    short = s
                    break
            
            if not short:
                print(f"‚ùå Short con ID '{clip_id}' no encontrado en pendientes")
                return
            
            # Analizar con el scorer
            print(f"üîç Analizando '{short['title']}'...")
            
            score_details = self.scorer.calculate_score({
                'video_path': short.get('video_path', ''),
                'audio_path': short.get('audio_path', ''),
                'subtitles': short.get('subtitles', ''),
                'duration_seconds': short.get('duration_seconds', 30)
            })
            
            print(f"\nüìä Resultados del an√°lisis:")
            print(f"   üéØ Score total: {score_details['total_score']}/100")
            print(f"   üîä Calidad de audio: {score_details['audio_score']}/30")
            print(f"   ‚è±Ô∏è Duraci√≥n √≥ptima: {score_details['duration_score']}/25")
            print(f"   üìù Subt√≠tulos: {score_details['subtitles_score']}/25")
            print(f"   üìπ Estabilidad visual: {score_details['video_score']}/20")
            
            # Mostrar recomendaci√≥n
            if score_details['total_score'] >= 80:
                print(f"\n‚úÖ Recomendaci√≥n: AUTO-APROBAR")
            elif score_details['total_score'] < 40:
                print(f"\n‚ùå Recomendaci√≥n: AUTO-RECHAZAR")
            else:
                print(f"\n‚è≥ Recomendaci√≥n: REVISI√ìN MANUAL")
                
        except Exception as e:
            print(f"‚ùå Error analizando short: {e}")
    
    def manage_templates(self):
        """Gestionar templates din√°micos"""
        print("\nüé® GESTI√ìN DE TEMPLATES DIN√ÅMICOS")
        print("-" * 40)
        
        print("1. üìã Listar templates disponibles")
        print("2. üëÅÔ∏è Ver detalles de template")
        print("3. üéØ Seleccionar template para contenido")
        print("4. ‚öôÔ∏è Configurar templates")
        print("5. üß™ Demo de selecci√≥n autom√°tica")
        print("0. üîô Volver")
        
        choice = input("\nüëâ Selecciona opci√≥n: ").strip()
        
        if choice == '1':
            self.list_templates()
        elif choice == '2':
            self.show_template_details()
        elif choice == '3':
            self.select_template_for_content()
        elif choice == '4':
            self.configure_templates()
        elif choice == '5':
            self.demo_template_selection()
    
    def list_templates(self):
        """Listar templates disponibles"""
        print("\nüìã TEMPLATES DISPONIBLES")
        print("-" * 40)
        
        try:
            templates = self.template_manager.list_templates_summary()
            
            if not templates:
                print("‚ùå No hay templates configurados")
                return
            
            for template in templates:
                status = "‚úÖ" if template['enabled'] else "‚ùå"
                priority = template['priority']
                
                print(f"{status} {template['id']}:")
                print(f"   üìù {template['name']}")
                print(f"   üí¨ {template['description']}")
                print(f"   üéØ Prioridad: {priority}")
                print()
                
        except Exception as e:
            print(f"‚ùå Error listando templates: {e}")
    
    def show_template_details(self):
        """Mostrar detalles de un template espec√≠fico"""
        print("\nüëÅÔ∏è DETALLES DE TEMPLATE")
        print("-" * 40)
        
        template_id = input("üìÑ Ingresa el ID del template: ").strip()
        
        if not template_id:
            print("‚ùå Template ID requerido")
            return
        
        try:
            details = self.template_manager.get_template_preview(template_id)
            
            if 'error' in details:
                print(f"‚ùå {details['error']}")
                return
            
            print(f"üé® {details['name']}")
            print(f"üí¨ {details['description']}")
            print(f"üéØ Prioridad: {details['priority']}")
            print(f"üìä Estado: {'‚úÖ Habilitado' if details['enabled'] else '‚ùå Deshabilitado'}")
            
            print(f"\n‚ú® Caracter√≠sticas:")
            features = details['features']
            print(f"   üìù Fondo en subt√≠tulos: {'‚úÖ' if features['subtitle_background'] else '‚ùå'}")
            print(f"   üè∑Ô∏è Marca de agua: {'‚úÖ' if features['watermark'] else '‚ùå'}")
            print(f"   üîä Normalizaci√≥n de audio: {'‚úÖ' if features['audio_normalization'] else '‚ùå'}")
            print(f"   üé¨ Efectos de video: {', '.join(features['video_effects'])}")
            
            print(f"\nüéØ Vista previa del estilo:")
            style = details['style_preview']
            print(f"   üî§ Fuente: {style['font_family']}")
            print(f"   üìè Tama√±o: {style['font_size']}px")
            print(f"   üé® Color: {style['font_color']}")
            print(f"   üìç Posici√≥n: {style['position']}")
            
        except Exception as e:
            print(f"‚ùå Error mostrando detalles: {e}")
    
    def select_template_for_content(self):
        """Seleccionar template para contenido espec√≠fico"""
        print("\nüéØ SELECCI√ìN DE TEMPLATE PARA CONTENIDO")
        print("-" * 40)
        
        print("Ingresa informaci√≥n del contenido:")
        title = input("üìù T√≠tulo: ").strip()
        duration = input("‚è±Ô∏è Duraci√≥n (segundos, default 30): ").strip()
        quality = input("üéØ Score de calidad (0-100, default 50): ").strip()
        
        # Valores por defecto
        duration = int(duration) if duration.isdigit() else 30
        quality = int(quality) if quality.isdigit() and 0 <= int(quality) <= 100 else 50
        
        content_info = {
            'original_title': title,
            'duration_seconds': duration,
            'quality_score': quality
        }
        
        try:
            selected = self.template_manager.select_template_for_content(content_info)
            
            print(f"\nüé® Template seleccionado: {selected}")
            
            # Mostrar detalles del template seleccionado
            details = self.template_manager.get_template_preview(selected)
            print(f"üìù {details['name']}")
            print(f"üí¨ {details['description']}")
            
        except Exception as e:
            print(f"‚ùå Error seleccionando template: {e}")
    
    def configure_templates(self):
        """Configurar templates"""
        print("\n‚öôÔ∏è CONFIGURACI√ìN DE TEMPLATES")
        print("-" * 40)
        
        print("üìÅ Archivo de configuraci√≥n: configs/templates.yaml")
        print("‚úèÔ∏è Para editar templates, modifica el archivo de configuraci√≥n")
        print("üîÑ Reinicia la aplicaci√≥n para aplicar cambios")
        
        print("\nüìñ Estructura de template:")
        print("   ‚Ä¢ name: Nombre descriptivo")
        print("   ‚Ä¢ description: Descripci√≥n del estilo")  
        print("   ‚Ä¢ subtitle_style: Estilo de subt√≠tulos")
        print("   ‚Ä¢ branding: Configuraci√≥n de marca")
        print("   ‚Ä¢ video_effects: Efectos de video")
        print("   ‚Ä¢ audio_effects: Efectos de audio")
        print("   ‚Ä¢ priority: Prioridad (mayor = preferido)")
        print("   ‚Ä¢ enabled: true/false")
    
    def demo_template_selection(self):
        """Demo de selecci√≥n autom√°tica de templates"""
        print("\nüß™ DEMO: SELECCI√ìN AUTOM√ÅTICA DE TEMPLATES")
        print("-" * 40)
        
        # Ejemplos de contenido
        examples = [
            {
                'original_title': 'C√≥mo programar en Python - Tutorial completo',
                'duration_seconds': 45,
                'quality_score': 85,
                'description': 'Tutorial paso a paso para aprender Python'
            },
            {
                'original_title': 'EPIC Gaming Moments - Best Highlights',
                'duration_seconds': 30,
                'quality_score': 70,
                'description': 'Gaming highlights and epic moments compilation'
            },
            {
                'original_title': 'Mi rutina diaria - Lifestyle Vlog',
                'duration_seconds': 60,
                'quality_score': 60,
                'description': 'Comparto mi d√≠a a d√≠a y rutina personal'
            }
        ]
        
        try:
            for i, content in enumerate(examples, 1):
                selected = self.template_manager.select_template_for_content(content)
                details = self.template_manager.get_template_preview(selected)
                
                print(f"\n{i}. üì∫ '{content['original_title'][:50]}...'")
                print(f"   ‚è±Ô∏è Duraci√≥n: {content['duration_seconds']}s")
                print(f"   üéØ Calidad: {content['quality_score']}/100")
                print(f"   üé® Template seleccionado: {details['name']}")
                print(f"   üí¨ Raz√≥n: Optimizado para este tipo de contenido")
                
        except Exception as e:
            print(f"‚ùå Error en demo: {e}")
    
    def manage_channels_videos(self):
        """Gesti√≥n manual de canales y videos"""
        print("\nüì∫ GESTI√ìN DE CANALES Y VIDEOS")
        print("-" * 40)
        
        print("1. üìã Ver todos los canales")
        print("2. ‚ûï A√±adir canal manualmente")
        print("3. üìπ Ver videos de un canal")
        print("4. ‚ûï A√±adir video manualmente")
        print("5. üîç Analizar URL de YouTube")
        print("6. üóëÔ∏è Eliminar canal")
        print("7. üóëÔ∏è Eliminar video")
        print("8. üìä Estad√≠sticas de canales")
        print("0. üîô Volver")
        
        choice = input("\nüëâ Selecciona opci√≥n: ").strip()
        
        if choice == '1':
            self.list_all_channels()
        elif choice == '2':
            self.add_channel_manually()
        elif choice == '3':
            self.view_channel_videos()
        elif choice == '4':
            self.add_video_manually()
        elif choice == '5':
            self.analyze_youtube_url()
        elif choice == '6':
            self.delete_channel()
        elif choice == '7':
            self.delete_video()
        elif choice == '8':
            self.show_channel_stats()
    
    def list_all_channels(self):
        """Listar todos los canales registrados"""
        print("\nüìã CANALES REGISTRADOS")
        print("-" * 40)
        
        try:
            channels = self.db.get_all_channels()
            
            if not channels:
                print("üì≠ No hay canales registrados")
                return
            
            print(f"üìä Total de canales: {len(channels)}")
            print()
            
            for i, channel in enumerate(channels, 1):
                status = "‚úÖ" if channel['is_active'] else "‚ùå"
                print(f"{i}. {status} {channel['name']}")
                print(f"   üÜî ID: {channel['channel_id']}")
                print(f"   üë• Suscriptores: {channel.get('subscriber_count', 0):,}")
                print(f"   üìπ Videos: {channel['total_videos']} ({channel['processed_videos']} procesados)")
                print(f"   üìÖ Descubierto: {channel['discovered_at'][:10]}")
                print(f"   üîó URL: {channel.get('url', 'N/A')}")
                
                if channel.get('description'):
                    desc = channel['description'][:100] + ('...' if len(channel['description']) > 100 else '')
                    print(f"   üí¨ {desc}")
                print()
                
        except Exception as e:
            print(f"‚ùå Error listando canales: {e}")
    
    def add_channel_manually(self):
        """A√±adir canal manualmente"""
        print("\n‚ûï A√ëADIR CANAL MANUALMENTE")
        print("-" * 40)
        
        if not YOUTUBE_PARSER_AVAILABLE:
            print("‚ö†Ô∏è  Parser de YouTube no disponible. Modo manual b√°sico.")
            
            channel_id = input("üÜî Channel ID (UCxxxx...): ").strip()
            channel_name = input("üìù Nombre del canal: ").strip()
            channel_url = input("üîó URL (opcional): ").strip()
            description = input("üí¨ Descripci√≥n (opcional): ").strip()
            
            try:
                subscriber_count = int(input("üë• N√∫mero de suscriptores (0): ").strip() or "0")
            except ValueError:
                subscriber_count = 0
            
            if not channel_id or not channel_name:
                print("‚ùå Channel ID y nombre son requeridos")
                return
            
            # Validar formato de Channel ID b√°sico
            if not (channel_id.startswith('UC') and len(channel_id) == 24):
                confirm = input("‚ö†Ô∏è  El ID no tiene formato est√°ndar. ¬øContinuar? (s/N): ")
                if confirm.lower() != 's':
                    return
            
            confirm = input(f"\n‚úÖ ¬øA√±adir canal '{channel_name}'? (s/N): ")
            if confirm.lower() != 's':
                print("‚ùå Operaci√≥n cancelada")
                return
            
            success = self.db.add_channel_manually(
                channel_id=channel_id,
                channel_name=channel_name,
                channel_url=channel_url or f"https://www.youtube.com/channel/{channel_id}",
                description=description or f"Canal a√±adido manualmente: {channel_name}",
                subscriber_count=subscriber_count
            )
            
            if success:
                print(f"‚úÖ Canal '{channel_name}' a√±adido exitosamente")
            else:
                print(f"‚ùå Error a√±adiendo canal (posiblemente ya existe)")
            
            return
        
        # Resto del c√≥digo con parser...
        print("Puedes usar:")
        print("‚Ä¢ URL completa: https://www.youtube.com/channel/UCxxxx")
        print("‚Ä¢ URL con @: https://www.youtube.com/@nombrecanal")
        print("‚Ä¢ Solo el ID: UCxxxxxxxxxxxxxxxxxxxx")
        print("‚Ä¢ Solo el @: @nombrecanal")
        
        url_input = input("\nüîó URL o ID del canal: ").strip()
        
        if not url_input:
            print("‚ùå URL o ID requerido")
            return
        
        try:
            print("üîç Analizando canal...")
            
            # Si es una URL completa, parsearla
            if url_input.startswith('http') or '@' in url_input:
                result = parse_youtube_url(url_input)
                if result['type'] != 'channel':
                    print(f"‚ùå URL no reconocida como canal: {result.get('data', {}).get('error', 'Error desconocido')}")
                    return
                
                channel_info = result['data']
            else:
                # Asumir que es un ID directo
                channel_info = self.youtube_parser.get_channel_info_from_page(url_input)
            
            if 'error' in channel_info:
                print(f"‚ùå Error obteniendo informaci√≥n: {channel_info['error']}")
                return
            
            # Mostrar informaci√≥n encontrada
            print(f"\nüì∫ Informaci√≥n encontrada:")
            print(f"   üÜî ID: {channel_info['channel_id']}")
            print(f"   üìù Nombre: {channel_info['name']}")
            print(f"   üë• Suscriptores: {channel_info.get('subscriber_count', 0):,}")
            print(f"   üîó URL: {channel_info['url']}")
            
            if channel_info.get('description'):
                desc = channel_info['description'][:200] + ('...' if len(channel_info['description']) > 200 else '')
                print(f"   üí¨ Descripci√≥n: {desc}")
            
            # Confirmaci√≥n
            confirm = input(f"\n‚úÖ ¬øA√±adir este canal? (s/N): ")
            if confirm.lower() != 's':
                print("‚ùå Operaci√≥n cancelada")
                return
            
            # A√±adir a la base de datos
            success = self.db.add_channel_manually(
                channel_id=channel_info['channel_id'],
                channel_name=channel_info['name'],
                channel_url=channel_info['url'],
                description=channel_info.get('description'),
                subscriber_count=channel_info.get('subscriber_count', 0)
            )
            
            if success:
                print(f"‚úÖ Canal '{channel_info['name']}' a√±adido exitosamente")
            else:
                print(f"‚ùå Error a√±adiendo canal (posiblemente ya existe)")
                
        except Exception as e:
            print(f"‚ùå Error a√±adiendo canal: {e}")
    
    def view_channel_videos(self):
        """Ver videos de un canal espec√≠fico"""
        print("\nüìπ VIDEOS POR CANAL")
        print("-" * 40)
        
        # Primero mostrar canales disponibles
        channels = self.db.get_all_channels()
        if not channels:
            print("üì≠ No hay canales registrados")
            return
        
        print("Canales disponibles:")
        for i, channel in enumerate(channels, 1):
            print(f"{i}. {channel['name']} ({channel['total_videos']} videos)")
        
        try:
            selection = input("\nüëâ Selecciona canal (n√∫mero o ID): ").strip()
            
            # Si es un n√∫mero, usar √≠ndice
            if selection.isdigit():
                idx = int(selection) - 1
                if 0 <= idx < len(channels):
                    channel_id = channels[idx]['channel_id']
                    channel_name = channels[idx]['name']
                else:
                    print("‚ùå N√∫mero de canal inv√°lido")
                    return
            else:
                # Asumir que es un channel_id
                channel_id = selection
                channel_name = channel_id
            
            # Obtener videos del canal
            videos = self.db.get_videos_by_channel(channel_id, limit=20)
            
            if not videos:
                print(f"üì≠ No hay videos en el canal {channel_name}")
                return
            
            print(f"\nüìπ Videos en {channel_name} (√∫ltimos {len(videos)}):")
            print("-" * 60)
            
            for i, video in enumerate(videos, 1):
                processed = "‚úÖ" if video['processed'] else "‚è≥"
                print(f"{i}. {processed} {video['title']}")
                print(f"   üÜî ID: {video['video_id']}")
                print(f"   ‚è±Ô∏è  Duraci√≥n: {format_duration(video.get('duration_seconds', 0))}")
                print(f"   üìÖ Publicado: {video.get('published_at', 'N/A')[:10]}")
                print(f"   üé¨ Segmentos: {video.get('total_segments', 0)}")
                print(f"   üì¶ Composites: {video.get('total_composites', 0)}")
                print(f"   üîó URL: {video.get('url', 'N/A')}")
                print()
                
        except Exception as e:
            print(f"‚ùå Error mostrando videos: {e}")
    
    def add_video_manually(self):
        """A√±adir video manualmente"""
        print("\n‚ûï A√ëADIR VIDEO MANUALMENTE")
        print("-" * 40)
        
        # Primero mostrar canales disponibles
        channels = self.db.get_all_channels()
        if not channels:
            print("‚ùå No hay canales registrados. A√±ade un canal primero.")
            return
        
        print("Canales disponibles:")
        for i, channel in enumerate(channels, 1):
            print(f"{i}. {channel['name']} ({channel['channel_id']})")
        
        if not YOUTUBE_PARSER_AVAILABLE:
            print("\n‚ö†Ô∏è  Parser de YouTube no disponible. Modo manual b√°sico.")
            
            video_id = input("üÜî Video ID (11 caracteres): ").strip()
            title = input("üìù T√≠tulo del video: ").strip()
            url = input("üîó URL (opcional): ").strip()
            
            try:
                duration = int(input("‚è±Ô∏è Duraci√≥n en segundos (0): ").strip() or "0")
            except ValueError:
                duration = 0
            
            description = input("üí¨ Descripci√≥n (opcional): ").strip()
            published_at = input("üìÖ Fecha publicaci√≥n (YYYY-MM-DD, opcional): ").strip()
            
            if not video_id or not title:
                print("‚ùå Video ID y t√≠tulo son requeridos")
                return
            
            # Validar formato b√°sico del Video ID
            if len(video_id) != 11:
                confirm = input("‚ö†Ô∏è  El ID no tiene 11 caracteres. ¬øContinuar? (s/N): ")
                if confirm.lower() != 's':
                    return
            
            # Seleccionar canal
            selection = input("üëâ Selecciona canal (n√∫mero): ").strip()
            
            if not selection.isdigit():
                print("‚ùå Selecci√≥n inv√°lida")
                return
                
            idx = int(selection) - 1
            if not (0 <= idx < len(channels)):
                print("‚ùå N√∫mero de canal inv√°lido")
                return
            
            target_channel_id = channels[idx]['channel_id']
            
            confirm = input(f"\n‚úÖ ¬øA√±adir video '{title}'? (s/N): ")
            if confirm.lower() != 's':
                print("‚ùå Operaci√≥n cancelada")
                return
            
            success = self.db.add_video_manually(
                video_id=video_id,
                channel_id=target_channel_id,
                title=title,
                url=url or f"https://www.youtube.com/watch?v={video_id}",
                duration_seconds=duration,
                description=description,
                published_at=published_at
            )
            
            if success:
                print(f"‚úÖ Video '{title}' a√±adido exitosamente")
            else:
                print(f"‚ùå Error a√±adiendo video (posiblemente ya existe)")
            
            return
        
        # Resto del c√≥digo con parser...
        print("\nPuedes usar:")
        print("‚Ä¢ URL completa: https://www.youtube.com/watch?v=xxxxxxx")
        print("‚Ä¢ URL corta: https://youtu.be/xxxxxxx")
        print("‚Ä¢ Solo el ID: xxxxxxxxxxx")
        
        url_input = input("\nüîó URL o ID del video: ").strip()
        
        if not url_input:
            print("‚ùå URL o ID requerido")
            return
        
        try:
            print("üîç Analizando video...")
            
            # Si es una URL completa, parsearla
            if url_input.startswith('http'):
                result = parse_youtube_url(url_input)
                if result['type'] != 'video':
                    print(f"‚ùå URL no reconocida como video: {result.get('data', {}).get('error', 'Error desconocido')}")
                    return
                
                video_info = result['data']
            else:
                # Asumir que es un ID directo
                video_info = self.youtube_parser.get_video_info_from_page(url_input)
            
            if 'error' in video_info:
                print(f"‚ùå Error obteniendo informaci√≥n: {video_info['error']}")
                return
            
            # Mostrar informaci√≥n encontrada
            print(f"\nüì∫ Informaci√≥n encontrada:")
            print(f"   üÜî ID: {video_info['video_id']}")
            print(f"   üìù T√≠tulo: {video_info['title']}")
            print(f"   üì∫ Canal: {video_info['channel_name']}")
            print(f"   üÜî Canal ID: {video_info.get('channel_id', 'N/A')}")
            print(f"   ‚è±Ô∏è  Duraci√≥n: {format_duration(video_info.get('duration_seconds', 0))}")
            print(f"   üìÖ Publicado: {video_info.get('published_at', 'N/A')}")
            print(f"   üîó URL: {video_info['url']}")
            
            if video_info.get('description'):
                desc = video_info['description'][:200] + ('...' if len(video_info['description']) > 200 else '')
                print(f"   üí¨ Descripci√≥n: {desc}")
            
            # Seleccionar canal de destino
            print(f"\nüì∫ Seleccionar canal de destino:")
            
            # Si el video tiene channel_id, intentar encontrarlo
            target_channel_id = None
            if video_info.get('channel_id'):
                for channel in channels:
                    if channel['channel_id'] == video_info['channel_id']:
                        target_channel_id = channel['channel_id']
                        print(f"   ‚úÖ Canal encontrado autom√°ticamente: {channel['name']}")
                        break
            
            if not target_channel_id:
                selection = input("üëâ Selecciona canal (n√∫mero): ").strip()
                
                if selection.isdigit():
                    idx = int(selection) - 1
                    if 0 <= idx < len(channels):
                        target_channel_id = channels[idx]['channel_id']
                    else:
                        print("‚ùå N√∫mero de canal inv√°lido")
                        return
                else:
                    print("‚ùå Selecci√≥n inv√°lida")
                    return
            
            # Confirmaci√≥n
            confirm = input(f"\n‚úÖ ¬øA√±adir este video? (s/N): ")
            if confirm.lower() != 's':
                print("‚ùå Operaci√≥n cancelada")
                return
            
            # A√±adir a la base de datos
            success = self.db.add_video_manually(
                video_id=video_info['video_id'],
                channel_id=target_channel_id,
                title=video_info['title'],
                url=video_info['url'],
                duration_seconds=video_info.get('duration_seconds', 0),
                description=video_info.get('description'),
                published_at=video_info.get('published_at')
            )
            
            if success:
                print(f"‚úÖ Video '{video_info['title']}' a√±adido exitosamente")
            else:
                print(f"‚ùå Error a√±adiendo video (posiblemente ya existe)")
                
        except Exception as e:
            print(f"‚ùå Error a√±adiendo video: {e}")
    
    def analyze_youtube_url(self):
        """Analizar cualquier URL de YouTube"""
        print("\nüîç ANALIZAR URL DE YOUTUBE")
        print("-" * 40)
        
        if not YOUTUBE_PARSER_AVAILABLE:
            print("‚ùå Parser de YouTube no disponible")
            print("   Instala las dependencias necesarias para usar esta funci√≥n")
            return
        
        url = input("üîó Ingresa URL de YouTube: ").strip()
        
        if not url:
            print("‚ùå URL requerida")
            return
        
        try:
            print("üîç Analizando...")
            result = parse_youtube_url(url)
            
            print(f"\nüìä Tipo detectado: {result['type'].upper()}")
            
            if result['type'] == 'video':
                data = result['data']
                print(f"   üÜî Video ID: {data['video_id']}")
                print(f"   üìù T√≠tulo: {data['title']}")
                print(f"   üì∫ Canal: {data['channel_name']}")
                print(f"   üÜî Canal ID: {data.get('channel_id', 'N/A')}")
                print(f"   ‚è±Ô∏è  Duraci√≥n: {format_duration(data.get('duration_seconds', 0))}")
                print(f"   üìÖ Publicado: {data.get('published_at', 'N/A')}")
                
                if data.get('description'):
                    desc = data['description'][:150] + ('...' if len(data['description']) > 150 else '')
                    print(f"   üí¨ Descripci√≥n: {desc}")
                    
            elif result['type'] == 'channel':
                data = result['data']
                print(f"   üÜî Canal ID: {data['channel_id']}")
                print(f"   üìù Nombre: {data['name']}")
                print(f"   üë• Suscriptores: {data.get('subscriber_count', 0):,}")
                
                if data.get('description'):
                    desc = data['description'][:150] + ('...' if len(data['description']) > 150 else '')
                    print(f"   üí¨ Descripci√≥n: {desc}")
                    
            else:
                print(f"   ‚ùå {result['data'].get('error', 'URL no reconocida')}")
            
        except Exception as e:
            print(f"‚ùå Error analizando URL: {e}")
    
    def delete_channel(self):
        """Eliminar canal"""
        print("\nüóëÔ∏è ELIMINAR CANAL")
        print("-" * 40)
        
        channels = self.db.get_all_channels()
        if not channels:
            print("üì≠ No hay canales registrados")
            return
        
        print("Canales disponibles:")
        for i, channel in enumerate(channels, 1):
            print(f"{i}. {channel['name']} ({channel['total_videos']} videos)")
        
        try:
            selection = input("\nüëâ Selecciona canal a eliminar (n√∫mero): ").strip()
            
            if not selection.isdigit():
                print("‚ùå Selecci√≥n inv√°lida")
                return
            
            idx = int(selection) - 1
            if not (0 <= idx < len(channels)):
                print("‚ùå N√∫mero de canal inv√°lido")
                return
            
            channel = channels[idx]
            
            print(f"\n‚ö†Ô∏è  Canal seleccionado: {channel['name']}")
            print(f"   üÜî ID: {channel['channel_id']}")
            print(f"   üìπ Videos asociados: {channel['total_videos']}")
            
            if channel['total_videos'] > 0:
                cascade = input("üóëÔ∏è ¬øEliminar tambi√©n todos los videos asociados? (s/N): ")
                cascade_delete = cascade.lower() == 's'
                
                if not cascade_delete:
                    print("‚ùå No se puede eliminar canal con videos asociados sin cascada")
                    return
            else:
                cascade_delete = False
            
            confirm = input(f"\n‚ö†Ô∏è  ¬øCONFIRMAR eliminaci√≥n de '{channel['name']}'? (s/N): ")
            if confirm.lower() != 's':
                print("‚ùå Operaci√≥n cancelada")
                return
            
            success = self.db.delete_channel(channel['channel_id'], cascade=cascade_delete)
            
            if success:
                print(f"‚úÖ Canal '{channel['name']}' eliminado exitosamente")
            else:
                print(f"‚ùå Error eliminando canal")
                
        except Exception as e:
            print(f"‚ùå Error eliminando canal: {e}")
    
    def delete_video(self):
        """Eliminar video"""
        print("\nüóëÔ∏è ELIMINAR VIDEO")
        print("-" * 40)
        
        channels = self.db.get_all_channels()
        if not channels:
            print("üì≠ No hay canales registrados")
            return
        
        print("Canales disponibles:")
        for i, channel in enumerate(channels, 1):
            print(f"{i}. {channel['name']} ({channel['total_videos']} videos)")
        
        try:
            selection = input("\nüëâ Selecciona canal (n√∫mero): ").strip()
            
            if not selection.isdigit():
                print("‚ùå Selecci√≥n inv√°lida")
                return
            
            idx = int(selection) - 1
            if not (0 <= idx < len(channels)):
                print("‚ùå N√∫mero de canal inv√°lido")
                return
            
            channel = channels[idx]
            videos = self.db.get_videos_by_channel(channel['channel_id'], limit=20)
            
            if not videos:
                print(f"üì≠ No hay videos en el canal {channel['name']}")
                return
            
            print(f"\nVideos en {channel['name']}:")
            for i, video in enumerate(videos, 1):
                print(f"{i}. {video['title'][:50]}... ({video['video_id']})")
            
            video_selection = input("\nüëâ Selecciona video a eliminar (n√∫mero): ").strip()
            
            if not video_selection.isdigit():
                print("‚ùå Selecci√≥n inv√°lida")
                return
            
            video_idx = int(video_selection) - 1
            if not (0 <= video_idx < len(videos)):
                print("‚ùå N√∫mero de video inv√°lido")
                return
            
            video = videos[video_idx]
            
            print(f"\n‚ö†Ô∏è  Video seleccionado: {video['title']}")
            print(f"   üÜî ID: {video['video_id']}")
            print(f"   üé¨ Segmentos asociados: {video.get('total_segments', 0)}")
            print(f"   üì¶ Composites asociados: {video.get('total_composites', 0)}")
            
            if video.get('total_segments', 0) > 0:
                cascade = input("üóëÔ∏è ¬øEliminar tambi√©n segmentos y composites asociados? (s/N): ")
                cascade_delete = cascade.lower() == 's'
                
                if not cascade_delete:
                    print("‚ùå No se puede eliminar video con segmentos asociados sin cascada")
                    return
            else:
                cascade_delete = False
            
            confirm = input(f"\n‚ö†Ô∏è  ¬øCONFIRMAR eliminaci√≥n de '{video['title']}'? (s/N): ")
            if confirm.lower() != 's':
                print("‚ùå Operaci√≥n cancelada")
                return
            
            success = self.db.delete_video(video['video_id'], cascade=cascade_delete)
            
            if success:
                print(f"‚úÖ Video '{video['title']}' eliminado exitosamente")
            else:
                print(f"‚ùå Error eliminando video")
                
        except Exception as e:
            print(f"‚ùå Error eliminando video: {e}")
    
    def show_channel_stats(self):
        """Mostrar estad√≠sticas de canales"""
        print("\nüìä ESTAD√çSTICAS DE CANALES")
        print("-" * 40)
        
        try:
            channels = self.db.get_all_channels()
            
            if not channels:
                print("üì≠ No hay canales registrados")
                return
            
            # Estad√≠sticas generales
            total_channels = len(channels)
            active_channels = sum(1 for c in channels if c['is_active'])
            total_videos = sum(c['total_videos'] for c in channels)
            processed_videos = sum(c['processed_videos'] for c in channels)
            total_subscribers = sum(c.get('subscriber_count', 0) for c in channels)
            
            print(f"üìä Resumen General:")
            print(f"   üì∫ Total de canales: {total_channels}")
            print(f"   ‚úÖ Canales activos: {active_channels}")
            print(f"   üìπ Total de videos: {total_videos}")
            print(f"   ‚úÖ Videos procesados: {processed_videos}")
            print(f"   üë• Suscriptores totales: {total_subscribers:,}")
            
            if total_videos > 0:
                processing_rate = (processed_videos / total_videos) * 100
                print(f"   üìà Tasa de procesamiento: {processing_rate:.1f}%")
            
            print(f"\nüèÜ Top 5 Canales por Videos:")
            top_channels = sorted(channels, key=lambda x: x['total_videos'], reverse=True)[:5]
            
            for i, channel in enumerate(top_channels, 1):
                status = "‚úÖ" if channel['is_active'] else "‚ùå"
                print(f"   {i}. {status} {channel['name']}")
                print(f"      üìπ Videos: {channel['total_videos']} ({channel['processed_videos']} procesados)")
                print(f"      üë• Suscriptores: {channel.get('subscriber_count', 0):,}")
            
            print(f"\nüë• Top 3 Canales por Suscriptores:")
            top_subs = sorted(channels, key=lambda x: x.get('subscriber_count', 0), reverse=True)[:3]
            
            for i, channel in enumerate(top_subs, 1):
                if channel.get('subscriber_count', 0) > 0:
                    print(f"   {i}. {channel['name']}")
                    print(f"      üë• {channel['subscriber_count']:,} suscriptores")
                    print(f"      üìπ {channel['total_videos']} videos")
                    
        except Exception as e:
            print(f"‚ùå Error mostrando estad√≠sticas: {e}")
    
    def run(self):
        """Ejecutar interfaz CLI"""
        self.show_banner()
        
        while self.running:
            try:
                self.show_menu()
                choice = input("üëâ Selecciona una opci√≥n: ").strip()
                
                if choice == '1':
                    self.show_stats()
                elif choice == '2':
                    self.show_pending_queue()
                elif choice == '3':
                    self.approve_short()
                elif choice == '4':
                    self.reject_short()
                elif choice == '5':
                    self.schedule_short()
                elif choice == '6':
                    self.bulk_operations()
                elif choice == '7':
                    self.toggle_daemon()
                elif choice == '8':
                    self.publish_approved()
                elif choice == '9':
                    self.show_system_info()
                elif choice.lower() == 'scoring' or choice == 'üéØ':
                    self.run_auto_scoring()
                elif choice.lower() == 'templates' or choice == 'üé®':
                    self.manage_templates()
                elif choice.lower() == 'canales' or choice == 'üì∫':
                    self.manage_channels_videos()
                elif choice == '0':
                    print("üëã ¬°Hasta luego! Que recuperes pronto tu acceso a Telegram")
                    self.running = False
                else:
                    print("‚ùå Opci√≥n no v√°lida")
                
                if self.running and choice != '0':
                    input("\n‚è∏Ô∏è  Presiona Enter para continuar...")
                    
            except KeyboardInterrupt:
                print("\n\nüëã Saliendo... ¬°Hasta luego!")
                self.running = False
            except Exception as e:
                print(f"\n‚ùå Error: {e}")
                input("‚è∏Ô∏è  Presiona Enter para continuar...")

if __name__ == '__main__':
    cli = CLIControl()
    cli.run()
